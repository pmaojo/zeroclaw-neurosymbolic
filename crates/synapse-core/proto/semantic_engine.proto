syntax = "proto3";
package semantic_engine;

service SemanticEngine {
    // Ingests a batch of triples
    rpc IngestTriples (IngestRequest) returns (IngestResponse);

    // Ingests a file (CSV, Markdown)
    rpc IngestFile (IngestFileRequest) returns (IngestResponse);

    // Queries the graph (Basic traversal for now)
    rpc GetNeighbors (NodeRequest) returns (NeighborResponse);

    // Vector Search (Placeholder for hybrid query)
    rpc Search (SearchRequest) returns (SearchResponse);

    // Resolves a string URI to a Node ID
    rpc ResolveId (ResolveRequest) returns (ResolveResponse);

    // Get all stored triples (for graph visualization)
    rpc GetAllTriples (EmptyRequest) returns (TriplesResponse);

    // Executes a SPARQL query
    rpc QuerySparql (SparqlRequest) returns (SparqlResponse);

    // Deletes all data associated with a namespace
    rpc DeleteNamespaceData (EmptyRequest) returns (DeleteResponse);

    // Hybrid search combining vector similarity and graph traversal
    rpc HybridSearch (HybridSearchRequest) returns (SearchResponse);

    // Applies automated reasoning to a namespace
    rpc ApplyReasoning (ReasoningRequest) returns (ReasoningResponse);

    // Identifies important memories for consolidation/abstraction
    rpc ConsolidateMemory (ConsolidateRequest) returns (ConsolidateResponse);
}

message SparqlRequest {
    string query = 1;
    string namespace = 2;
}

message SparqlResponse {
    string results_json = 1;
}

message DeleteResponse {
    bool success = 1;
    string message = 2;
}

message Provenance {
    string source = 1;
    string timestamp = 2;
    string method = 3;
}

message Triple {
    string subject = 1;
    string predicate = 2;
    string object = 3;
    Provenance provenance = 4;
    repeated float embedding = 5;  // Vector embedding for hybrid search
}

message IngestRequest {
    repeated Triple triples = 1;
    string namespace = 2;
}

message IngestFileRequest {
    string file_path = 1;
    string namespace = 2;
}

message IngestResponse {
    uint32 nodes_added = 1;
    uint32 edges_added = 2;
}

message NodeRequest {
    uint32 node_id = 1;
    string namespace = 2;
    string direction = 3;       // "outgoing", "incoming", or "both" (default: "outgoing")
    uint32 depth = 4;           // Traversal depth (default: 1)
    string edge_filter = 5;     // Optional: filter by edge type (predicate)
    uint32 limit_per_layer = 6; // Max neighbors per depth level (0 = unlimited)
    string scoring_strategy = 7;// "default" or "degree" (penalize super-nodes)
    string node_type_filter = 8; // Optional: filter neighbors by rdf:type
}

message NeighborResponse {
    repeated Neighbor neighbors = 1;
}

message Neighbor {
    uint32 node_id = 1;
    string edge_type = 2;
    string uri = 3;           // Full URI of the neighbor
    string direction = 4;     // "outgoing" or "incoming"
    uint32 depth = 5;         // Depth at which this neighbor was found
    float score = 6;          // Path score (1.0 / depth by default)
}

message SearchRequest {
    string query = 1;
    uint32 limit = 2;
    string namespace = 3;
}

message SearchResponse {
    repeated SearchResult results = 1;
}

message SearchResult {
    uint32 node_id = 1;
    float score = 2;
    string content = 3;
    string uri = 4;  // Full URI of the entity
}

enum SearchMode {
    VECTOR_ONLY = 0;
    GRAPH_ONLY = 1;
    HYBRID = 2;
}

message HybridSearchRequest {
    string query = 1;
    string namespace = 2;
    uint32 vector_k = 3;      // Top-K from vector search
    uint32 graph_depth = 4;   // Graph expansion depth (0 = no expansion)
    SearchMode mode = 5;      // Search strategy
    uint32 limit = 6;         // Final result limit
    bool spreading_activation = 7; // Use activation flow instead of BFS
    float decay_factor = 8;   // Activation decay per hop (0.0 - 1.0, default 0.8)
    float time_weight = 9;    // Importance of recency (0.0 - 1.0, default 0.5)
}

message ResolveRequest {
    string content = 1;
    string namespace = 2;
}

message ResolveResponse {
    uint32 node_id = 1;
    bool found = 2;
}

message EmptyRequest {
    string namespace = 1;
}

message TriplesResponse {
    repeated Triple triples = 1;
}

message ReasoningRequest {
    string namespace = 1;
    ReasoningStrategy strategy = 2;
    bool materialize = 3;  // Whether to save inferred triples to the store
}

enum ReasoningStrategy {
    NONE = 0;
    RDFS = 1;
    OWLRL = 2;
}

message ReasoningResponse {
    bool success = 1;
    uint32 triples_inferred = 2;
    string message = 3;
}

message ConsolidateRequest {
    string namespace = 1;
    float activation_threshold = 2; // Min activation to consider important
    uint32 limit = 3;               // Max episodes to return
}

message ConsolidateResponse {
    repeated Episode episodes = 1;
}

message Episode {
    string uri = 1;
    string content = 2;
    string timestamp = 3;
    float activation = 4;
    repeated string related_entities = 5;
}
